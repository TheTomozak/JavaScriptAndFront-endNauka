Template literals: uÅ¼ywanie takich ciapek ```` umoÅ¼liwia osadzanie obiektu w stringu 
{	let a = 5;
	let b = 10;
	console.log(`Fifteen is ${a + b} and
	not ${2 * a + b}.`);
	// "Fifteen is 15 and
	// not 20."
}

W js jak coÅ› nie istnieje to jest undefined, jak jest nullem to Å›wiadomie definujemy jako coÅ› pustego
w js wiele rzeczy jest faÅ‚szywymi wartoÅ›ciami : null, undefined, empty string, 0, false
	
$$$$$$$$$$ Destrukturyzacja $$$$$$$$$$$$

PodwÃ³jny znak rÃ³wnoÅ›ci igoruje typ ==:
2 == '2' daÅ‚o by true 
PotrÃ³jny znak rÃ³wnoÅ›ci patrzy i na wartosÄ‡ i na typ ===:
2 === '2' daÅ‚o by false


{
let a = 1;
let b = 2;

//MoÅ¼na zrobiÄ‡ po staremu 
const tmp = b;
b = a;
a = tmp;

//MoÅ¼na to zrobiÄ‡ proÅ›ciej za pomocÄ… destrukturyzacji
[a,b]=[b,a] //dopasowanie strukturalne czyli to wartosci po lewej stronie maja byc takie same jak po prawej stronie 


alert (a === 2 && b === 1) // chcemy zrobiÄ‡ Å¼eby to byÅ‚a prawda 
}



//==========================================================
//Destrukturyzacja na tablicach


let [a, b, c] = [1, 2, 3, 4, 5]; 	//przypisze do a = 1, b =2 , c =3

const arr = [1, 2, 3, 4, 5]; 
let spreadArr = [];
[a,,b, ...spreadArr] = arr;	 //u nas spread wpakuje caÅ‚Ä… resztÄ™ z arr do spreadArr

//wiec a = 1, b = 3, spreadArr = [4 ,5]

//"..." SkÅ‚adnia rozwiniÄ™cia (ang. spread syntax) pozwala na rozwiniÄ™cie iterowalnego wyraÅ¼enia,
//takiego jak wyraÅ¼enie tablicowe lub ciÄ…g znakÃ³w, tam gdzie oczekiwanych jest zero lub wiÄ™cej argumentÃ³w (dla wywoÅ‚aÅ„ funkcji) lub elementÃ³w (dla literaÅ‚Ã³w tablicowych).
//Pozwala rÃ³wnieÅ¼ na rozwiniÄ™cie wyraÅ¼eÅ„ obiektowych w miejscach, gdzie oczekiwanych jest zero lub wiÄ™cej par klucz-wartoÅ›Ä‡ (dla literaÅ‚Ã³w obiektowych).

//==========================================================
//Destrukturyzacja na obiektach

const book = {
    name: 'WiedÅºmin',
    author: 'Sapkowski'
};

const city = {
    name: 'Lublin',
    country: 'Poland'
}

introduce(book);
introduce(city);

function introduce(obj) {
    if(obj && obj.name) { 		//dziÄ™ki temu upewaniam siÄ™ Å¼e obiekt istnieje 
        alert(`To jest ${obj.name} i jest bardzo fajny.`);
    }
}

destrukturyzujÄ…c mozemy zapisaÄ‡ :
function introduce({name: n = 'domyÅ›lna wartoÅ›Ä‡ jak bÄ™dzie niezdefiniowane') = {} {
    if(obj && obj.name) { 		//dziÄ™ki temu upewaniam siÄ™ Å¼e obiekt istnieje 
        alert(`To jest ${obj.name} i jest bardzo fajny.`);
    }
}

destrukturyzujÄ…c mozemy zapisaÄ‡ teÅ¼ w taki sposÃ³b uwzglÄ™dniajaÄ‡ nulla :
function introduce(obj) {
    if(!obj ) {obj = {}) //podstawiamy domyÅ›lnÄ… wartoÅ›Ä‡ Å¼e obiekt przyjmuje wartoÅ›c pustego obiektu 
	const{name: n = 'domyÅ›lna wartoÅ›Ä‡ jak bÄ™dzie niezdefiniowane')} = obj;
    alert(`To jest ${obj.name} i jest bardzo fajny.`);
    
}

alert([...'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦']); za pomocÄ… spread'a rozdzieli nam emoji rodziny na poszczegolne emoji 



